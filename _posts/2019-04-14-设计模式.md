---
layout:     post
title:      设计模式（编写中）
subtitle:   Java语言讲解设计模式
date:       2019-04-15
author:     Dabiezi
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
    - 设计模式
---
# 设计模式概述
> 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。——维基百科[^1]

> 库与框架长久以来，一直扮演着软件开发过程的重要角色，我们从中挑选所要的组件，把它们放进合适的地方。但是……库与框架无法帮助我们将应用组织成容易了解、容易维护、具有弹性的架构，所以需要设计模式。——《Head First设计模式》[^2]

# 策略模式
> 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。——《Head First设计模式》[^2]

假如你是英雄联盟这款游戏的开发者，领导要你开发两个英雄，蒙多和阿卡丽，并且英雄携带召唤师技能，点燃和闪现。你想到java是门OO语言，每个英雄具有一些相同的属性和方法，所以你设计了一个Hero的超类，每个英雄必须继承这个超类。由于只有两个召唤师技能，所以你设计传入个参数i来判断召唤师技能。
```java
/**
 * 英雄超类
 */
public abstract class Hero {
    //英雄等级
    private int grade;

    //构造方法
    public Hero() {
        this.grade = 1;
    }

    //携带的召唤师技能
    public abstract void carry(int i);
}
```
蒙多类
```java
/**
 * 蒙多
 */
public class Mundo extends Hero {
    @Override
    public void carry(int i) {
        if(i == 1) {
            System.out.println("闪现");
        }else if(i == 2) {
            System.out.println("点燃");
        }
    }
}
```
阿卡丽类
```java
/**
 * 阿卡丽
 */
public class Akali extends Hero {
    @Override
    public void carry(int i) {
        if(i == 1) {
            System.out.println("闪现");
        }else if(i == 2) {
            System.out.println("点燃");
        }
    }
}
```
类图是这样
![UML](https://zhazige-com.oss-cn-qingdao.aliyuncs.com/design-mode/1.png?x-oss-process=style/watermark)

随着玩家的增多，领导开会决定再增加一个召唤师技能治疗。正在你打算增加子类中carry方法的判断条件时，你想到如果领导经常决定增加技能的话，岂不是每次
都得更改子类中carry方法，那岂不是太累啦，而且随着英雄的增多，这项工作愈发艰难。你想到是时候把召唤师技能独立出去了，于是你这样设计。

# 参考资料
[^1]: See Wikipedia,https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)
[^2]:（美）弗里曼等著.《Head First设计模式》.中国电力出版社，2007，9

