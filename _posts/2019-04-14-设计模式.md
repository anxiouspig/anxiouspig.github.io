---
layout:     post
title:      设计模式（编写中）
subtitle:   Java语言讲解设计模式
date:       2019-04-15
author:     Dabiezi
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - java
    - 设计模式
---
# 设计模式概述
> 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。——维基百科[^1]

> 库与框架长久以来，一直扮演着软件开发过程的重要角色，我们从中挑选所要的组件，把它们放进合适的地方。但是……库与框架无法帮助我们将应用组织成容易了解、容易维护、具有弹性的架构，所以需要设计模式。——《Head First设计模式》[^2]

# 策略模式（Strategy Pattern）
#### 举个例子
假设你是英雄联盟这款游戏的开发者，领导要你开发两个英雄，蒙多和阿卡丽，并且英雄携带召唤师技能，点燃和闪现。你想到java是门OO语言，每个英雄具有一些相同的属性和方法，所以你设计了一个Hero的超类，每个英雄必须继承这个超类。由于只有两个召唤师技能，所以你设计传入个参数i来判断召唤师技能。
```java
/**
 * 英雄超类
 */
public abstract class Hero {
    //英雄等级
    private int grade = 1;

    //携带的召唤师技能
    public abstract void carry(int i);
    
    //英雄台词
    public abstract void say();
}
```
```java
/**
 * 蒙多
 */
public class Mundo extends Hero {
    
    @Override
    public void say() {
        System.out.println("蒙多觉得你是个大娘们！");
    }
        
    @Override
    public void carry(int i) {
        if(i == 1) {
            System.out.println("闪现");
        }else if(i == 2) {
            System.out.println("点燃");
        }
    }
}
```
```java
/**
 * 阿卡丽
 */
public class Akali extends Hero {
    
    @Override
    public void say() {
        System.out.println("奉均衡之命。");
    }
        
    @Override
    public void carry(int i) {
        if(i == 1) {
            System.out.println("闪现");
        }else if(i == 2) {
            System.out.println("点燃");
        }
    }
}
```
```java
/**
 * 主类
 */
public class Main {
    public static void main(String[] args) {
        Hero akali = new Akali();
        akali.say();
        akali.carry(1);
        akali.carry(2);

        Hero mundo = new Mundo();
        mundo.say();
        mundo.carry(1);
        mundo.carry(2);
    }
}
```
```java
奉均衡之命。
闪现
点燃
蒙多觉得你是个大娘们！
闪现
点燃
```
类图如下
![UML](https://zhazige-com.oss-cn-qingdao.aliyuncs.com/design-mode/strategy-1.png?x-oss-process=style/watermark)

随着玩家的增多，领导开会决定再增加一个召唤师技能治疗。正在你打算增加子类中carry方法的判断条件时，你想到如果领导经常决定增加技能的话，岂不是每次
都得更改子类中carry方法，那岂不是太累啦，而且随着英雄的增多，这项工作愈发艰难。你想到是时候把召唤师技能独立出去了，于是你这样设计。
```java
/**
 * 技能接口
 */
public interface Skill {
    void release();
}
```
```java
/**
 * 治疗技能
 */
public class Treat implements Skill {

    //治疗量
    private int dose = 100;

    @Override
    public void release() {
        System.out.println("恢复"+dose+"滴血");
    }
}
```
```java
/**
 * 点燃技能
 */
public class Fire implements Skill {

    //造成的伤害
    private int harm = 100;

    @Override
    public void release() {
        System.out.println("点火造成伤害"+harm);
    }
}
```
```java
/**
 * 闪现技能
 */
public class Flash implements Skill {

    //闪现距离
    private int distance = 100;

    @Override
    public void release() {
        System.out.println("闪现了"+distance+"码");
    }
    
}
```
```java
/**
 * 英雄超类
 */
public abstract class Hero {
    //英雄等级
    private int grade = 1;
    //召唤师技能
    private Skill skill;

    //携带的召唤师技能
    public void carry() {
        skill.release();
    }

    //英雄台词
    public abstract void say();

    //设置召唤师技能
    public void setSkill(Skill skill) {
        this.skill = skill;
    }
}
```
```java
/**
 * 阿卡丽
 */
public class Akali extends Hero {

    @Override
    public void say() {
        System.out.println("奉均衡之命。");
    }
}
```
```java
/**
 * 蒙多
 * @author Dabiezi
 */
public class Mundo extends Hero {

    @Override
    public void say() {
        System.out.println("蒙多觉得你是个大娘们！");
    }
}
```
```java
/**
 * 主类
 */
public class Main {
    public static void main(String[] args) {
        Hero akali = new Akali();
        akali.say();
        akali.setSkill(new Fire());
        akali.carry();
        akali.setSkill(new Treat());
        akali.carry();

        Hero mundo = new Mundo();
        mundo.say();
        mundo.setSkill(new Flash());
        mundo.carry();
        mundo.setSkill(new Treat());
        mundo.carry();
    }
}

```
```java
奉均衡之命。
点火造成伤害100
恢复100滴血
蒙多觉得你是个大娘们！
闪现了100码
恢复100滴血
```
类图如下
![UML](https://zhazige-com.oss-cn-qingdao.aliyuncs.com/design-mode/strategy-2.png?x-oss-process=style/watermark)
我们把技能变为独立的类，再组合进Hero中，使用组合建立系统具有很大的弹性。

**策略模式定义——《Head First设计模式》[^2]**  
> 策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

**OO设计原则——《Head First设计模式》[^2]**  
> 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。

> 针对接口编程，而不是针对实现编程。

> 多用组合，少用继承

#### 策略模式在JDK中的应用

**Java Comparator 中的策略模式**  

//Arrays中的sort方法
```java
public static <T> void sort(T[] a, Comparator<? super T> c) {
    if (c == null) {
        sort(a);
    } else {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, c);
        else
            TimSort.sort(a, 0, a.length, c, null, 0, 0);
    }
}
```

**ThreadPoolExecutor中的四种拒绝策略**  

#### 策略模式在Spring框架中的应用

**Spring Resource 中的策略模式**  

**Spring Bean 实例化中的策略模式**  


# 观察者模式（Observer Pattern）
#### 举个例子
假设你所在的游戏公司要你开发一件新的游戏装备，主动效果是使用后给周围一千码内的友军回复100*使用者等级的生命值。你该如何设计？人物角色可以自由移动，那么一千码范围内的友军数量会变化，在你使用装备技能后，一千码内的友军会发出响应。你想到可以用观察者模式设计，友军是观察者，带装备的角色是被观察者。

```java
/**
 * 目标对象
 */
public interface Subject {

    void registerObserver(Observer o);

    void removeObserver(Observer o);

    void notifyObservers();

}
```
```java
/**
 * 佩戴装备的目标对象
 */
public class Equipment implements Subject {

    /**
     * 等级
     */
    private int grade;

    /**
     * 观察者集合
     */
    private ArrayList observers;

    /**
     * 构造方法，初始化集合
     */
    public Equipment() {
        this.observers = new ArrayList();
        this.grade = 1;
    }

    /**
     * 角色升级
     *
     * @param grade
     */
    public void setGrade(int grade) {
        this.grade = grade;
    }

    /**
     * 进入一千码范围内的友军，注册为观察者
     */
    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    /**
     * 离开一千码范围的友军，移除观察者
     */
    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i >= 0) {
            observers.remove(i);
        }
    }

    /**
     * 通知一千码内友军
     */
    @Override
    public void notifyObservers() {
        for (int i = 0; i < observers.size(); i++) {
            Observer observer = (Observer) observers.get(i);
            observer.update(grade * 100);
        }
    }

    /**
     * 释放技能
     */
    public void release() {
        notifyObservers();
    }
}
```
```java
/**
 * 观察接口
 */
public interface Observer {
    void update(Integer therapeuticDose);
}
```
```java
/**
 * 显示结果
 */
public interface DisplayResult {
    void display();
}
```
```java
/**
 * 角色1
 */
public class RoleOne implements Observer,DisplayResult {

    /**
     * 治疗量
     */
    private int therapeuticDose;

    /**
     * 目标角色
     */
    private Subject equipment;

    /**
     * 构造方法，注入目标角色
     * @param equipment
     */
    public RoleOne(Subject equipment) {
        this.equipment = equipment;
        equipment.registerObserver(this);
    }

    /**
     * 显示结果
     */
    @Override
    public void display() {
        System.out.println("RoleOne回复"+therapeuticDose+"生命值");
    }

    /**
     * 做出相应
     */
    @Override
    public void update(Integer therapeuticDose) {
        this.therapeuticDose = therapeuticDose;
        display();
    }
}
```
```java
/**
 * 角色2
 */
public class RoleTwo implements Observer,DisplayResult {

    /**
     * 治疗量
     */
    private int therapeuticDose;

    /**
     * 目标角色
     */
    private Subject equipment;

    /**
     * 构造方法，注入目标角色
     * @param equipment
     */
    public RoleTwo(Subject equipment) {
        this.equipment = equipment;
        equipment.registerObserver(this);
    }

    /**
     * 显示结果
     */
    @Override
    public void display() {
        System.out.println("RoleTwo回复"+therapeuticDose+"生命值");
    }

    /**
     * 做出相应
     */
    @Override
    public void update(Integer therapeuticDose) {
        this.therapeuticDose = therapeuticDose;
        display();
    }
}
```
```java
/**
 * main函数
 */
public class Main {
    public static void main(String[] args) {
        Equipment equipment = new Equipment();

        RoleOne roleOne = new RoleOne(equipment);
        RoleTwo roleTwo = new RoleTwo(equipment);

        System.out.println("roleOne和roleTwo均在一千码范围内");
        equipment.setGrade(6);
        equipment.release();
        System.out.println("roleTwo离开一千码范围");
        equipment.removeObserver(roleTwo);
        equipment.setGrade(8);
        equipment.release();
    }
}
```
```html
roleOne和roleTwo均在一千码范围内
RoleOne回复600生命值
RoleTwo回复600生命值
roleTwo离开一千码范围
RoleOne回复800生命值
```
类图如下
![UML](https://zhazige-com.oss-cn-qingdao.aliyuncs.com/design-mode/observer-1.png?x-oss-process=style/watermark)

**观察者模式定义——《Head First设计模式》[^2]**  
> 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

**OO设计原则——《Head First设计模式》[^2]**  
> 为了交互对象之间的松耦合设计而努力。

#### 策略模式在JDK中的应用

**java.util.Observable 中的观察者模式**  

#### 策略模式在Spring框架中的应用

**ApplicationContext 中的观察者模式**  

# 参考资料
[^1]: See Wikipedia,https://zh.wikipedia.org/wiki/设计模式_(计算机)
[^2]:（美）弗里曼等著.《Head First设计模式》.中国电力出版社，2007，9

