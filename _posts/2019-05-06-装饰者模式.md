---
layout:     post
title:      装饰者模式（Decorator Pattern）（编写中）
subtitle:   Java语言讲解装饰者模式
date:       2019-05-06
author:     Dabiezi
header-img: img/pexels-photo-1936936.jpeg
catalog: true
tags:
    - java
    - 设计模式
---
# 举个例子

#### 装饰者模式定义——《Head First设计模式》[^1]

> 装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

#### OO设计原则——《Head First设计模式》[^1]

> 类应该对扩展开放，对修改关闭。————遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用开放关闭原则。

# 装饰者模式在JDK中的应用

#### Java.io 中的装饰者模式

**编写自己的Java I/O装饰者**  

```java
public class LowerCaseInputStream extends FilterInputStream {


    public LowerCaseInputStream(InputStream in) {
        super(in);
    }

     @Override
     public int read() throws IOException {
        int c = super.read();
        return (c == -1 ? c : Character.toLowerCase((char)c));
     }

     @Override
    public int read(byte[] b, int offset, int len) throws IOException {
        int result = super.read(b, offset, len);
        for (int i = offset; i < offset+result; i++) {
            b[i] = (byte)Character.toLowerCase((char)b[i]);
         }
         return result;
     }

    public static void main(String[] args) {
        System.out.println(new File(".").getAbsolutePath());
        int c;
        try {
            InputStream in = new LowerCaseInputStream(
                    new BufferedInputStream(
                            new FileInputStream("../design-model/Strategy/src/decorator/test.txt")));

            while((c = in.read()) >= 0) {
                System.out.print((char)c);
            }

            in.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
```html
//test.txt
 I know the Decorator Pattern therefore I RULE!
 
//控制台打印
 i know the decorator pattern therefore i rule!
```


**Java.io引入装饰者模式的缺点[^1]**  

利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。

# 装饰者模式在Spring框架中的应用

# 参考资料
[^1]:（美）弗里曼等著.《Head First设计模式》.中国电力出版社，2007，9